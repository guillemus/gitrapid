---
globs: *.tsx
alwaysApply: false
---
## Local state: prefer useMutable over useState

**Rule**: Use `useMutable` for component-local state. Avoid `useState` in new code.

**Why**: The project favors local mutable state with Immer-style draft mutation, which `useMutable` provides [[memory:6967596]]. Keep responses concise [[memory:6544681]].

**Do**
- **Prefer**: `useMutable` from `src/client/utils` for all local state shapes (primitives, objects, arrays).
- **Mutate via drafts**: Update state by mutating the draft object/array directly.
- **Keep types strict**: Define explicit state shapes. Do not use `any`.

**Avoid**
- **Do not introduce** `useState` in new components.
- **Do not** use object spreads or deep cloning to update state; mutate the draft instead.

**When you must use useState**
- Only when a third-party API requires a React setter signature. If used, scope it narrowly and document the necessity in the PR/commit description. Prefer adapting the API to `useMutable` where feasible.

**Imports**
- Import from `src/client/utils`:

```ts
import { useMutable } from '@/client/utils'
```

**Usage patterns**
- Object state:

```tsx
type FormState = { title: string; count: number }
let state = useMutable<FormState>({ title: '', count: 0 })

function onChangeTitle(value: string) {
  state.title = value
}

function increment() {
  state.count += 1
}
```

- Discriminated unions:

```tsx
type View = { type: 'list' } | { type: 'details'; id: string }
let ui = useMutable<{ view: View }>({ view: { type: 'list' } })
ui.view = { type: 'details', id: '42' }
```

**Refactors**
- When encountering `useState`, propose migrating to `useMutable` unless blocked by a strict third-party API.
- Ensure all imports and call sites are updated accordingly.

**Typing**
- Never use `any` or `as any`. Use explicit types or generics with `useMutable`.

## Local state: prefer useMutable over useState

**Rule**: Use `useMutable` for component-local state. Avoid `useState` in new code.

**Why**: The project favors local mutable state with Immer-style draft mutation, which `useMutable` provides [[memory:6967596]]. Keep responses concise [[memory:6544681]].

**Do**
- **Prefer**: `useMutable` from `src/client/utils` for all local state shapes (primitives, objects, arrays).
- **Mutate via drafts**: Update state by mutating the draft object/array directly.
- **Keep types strict**: Define explicit state shapes. Do not use `any`.

**Avoid**
- **Do not introduce** `useState` in new components.
- **Do not** use object spreads or deep cloning to update state; mutate the draft instead.

**When you must use useState**
- Only when a third-party API requires a React setter signature. If used, scope it narrowly and document the necessity in the PR/commit description. Prefer adapting the API to `useMutable` where feasible.

**Imports**
- Import from `src/client/utils`:

```ts
import { useMutable } from '@/client/utils'
```

**Usage patterns**
- Object state:

```tsx
type FormState = { title: string; count: number }
let state = useMutable<FormState>({ title: '', count: 0 })

function onChangeTitle(value: string) {
  state.title = value
}

function increment() {
  state.count += 1
}
```

- Discriminated unions:

```tsx
type View = { type: 'list' } | { type: 'details'; id: string }
let ui = useMutable<{ view: View }>({ view: { type: 'list' } })
ui.view = { type: 'details', id: '42' }
```

**Refactors**
- When encountering `useState`, propose migrating to `useMutable` unless blocked by a strict third-party API.
- Ensure all imports and call sites are updated accordingly.

**Typing**
- Never use `any` or `as any`. Use explicit types or generics with `useMutable`.

