---
description: When writing typescript code that involves error handling
alwaysApply: false
---
### Error handling conventions

- **Goal**: Keep error flow explicit, typed, and predictable. Return Result-style values using the single error shape and helpers rather than throwing inside business logic.

- **Core primitives**
  - `err(message: string)`: return contextual human-readable error.
  - `ok(value?)`: return success value (optional value, defaults to null).
  - `tryCatch(promise)`: boundary wrapper for IO/SDK calls that converts throws into `err(...)`.
  - `unwrap(result)`: convert a result into its success value or cause a controlled bubble at very high-level boundaries.
  - `result.isErr`: property to detect the error shape â€” prefer this over checking properties directly.

- **Principles**
  - **Success is the success type**: Functions return either the success value (the given type) or an error.
  - **Single error shape**: All failing functions return an `Err`-shaped result; callers inspect failures with `result.isErr`.
  - **Minimize throwing**: Throw only for programmer errors or unrecoverable initialization failures. External/IO errors should be converted with `tryCatch`.
  - **Use `err` for all error conditions**: Use `err('failed to ...')` for expected, matchable conditions and contextual propagation.
  - **Use `err` for error codes**: Use `err('github-unauthorized' as const)` for error codes if needed.
  - **Use `wrap` for error context**: When propagating an error from a lower layer, use `wrap(context, error)` to add context.

- **Boundary vs business logic**
  - Boundary code (network, disk, third-party SDKs)
    - Use `tryCatch()` and convert to `err(...)`.
    - Examples:
      ```ts
      const got = await tryCatch(sdk.fetchThing())
      if (got.isErr) return wrap('failed to fetch thing', got)
      ```
      ```ts
      if (shouldMatchA !== shouldMatchB) return err('things dont match')
      ```
  - Business validation
    - Use `err('some-literal' as const)` for expected, matchable conditions.
    - Example:
      ```ts
      if (!repo) return err('not-found' as const)
      ```

- **Wrapping errors**
  - Good:
    ```ts
    const r = await doWork()
    if (r.isErr) return wrap('doWork', r)
    ```
  - Bad:
    ```ts
    if (r.isErr) return err(r.error) // loses useful wrapping context and it's redundant
    ```

- **When to throw**
  - Only for programmer errors or initialization where higher-level code cannot meaningfully proceed. Otherwise return `err`.

- **Consuming callers**
  - Pattern-match the returned error value directly. Example:
    ```ts
    const r = await service()
    if (r.isErr) {
      if (r.error === 'not-found') { /* handle not-found */ }
      return wrap('service error', r)
    }
    ```

- **Operational**
  - Convert `err` to logs/alerts at the application boundary (cron wrapper, HTTP handler). Avoid leaking sensitive data.

- **Anti-patterns**
  - No try/catch wrapping normal async flows.
  - No `err(r.error)` without adding wrapping context.
  - Do not check error shapes via direct property checks; use `result.isErr`.

- **Short examples**
  - Boundary:
    ```ts
    const maybe = await tryCatch(externalSdk.get())
    if (maybe.isErr) return wrap(`failed to get x`, maybe)
    ```
  - Business:
    ```ts
    if (!user) return err('not-found' as const)
    ```
  - Wrapping:
    ```ts
    const result = await someOperation()
    if (result.isErr) return wrap('someOperation', result)
    ```