---
description: When writing typescript code that involves error handling
alwaysApply: false
---

### Error handling conventions

- **Goal**: Keep error flow explicit, typed, and predictable. Return Result-style values using the single error shape and helpers rather than throwing inside business logic.

- **Core primitives**
  - `err(message: string)`: return contextual human-readable error.
  - `failure(code: string)`: return a machine-matchable failure value (typically a string literal like `'not-found'`).
  - `tryCatch(promise)`: boundary wrapper for IO/SDK calls that converts throws into `err(...)`.
  - `unwrap(result)`: convert a result into its success value or cause a controlled bubble at very high-level boundaries.
  - `isErr(value)`: helper to detect the error shape â€” prefer this over checking properties directly.

- **Principles**
  - **Success is the success type**: Functions return either the success value (the given type) or an error.
  - **Single error shape**: All failing functions return an `Err`-shaped result; callers inspect failures with `isErr(...)`.
  - **Minimize throwing**: Throw only for programmer errors or unrecoverable initialization failures. External/IO errors should be converted with `tryCatch`.
  - **Use `failure` for pattern-matchable conditions**: Use `failure('not-found')` (a literal error value) when callers should match on that exact error.
  - **Use `err` for contextual propagation**: When propagating an unexpected error from a lower layer, wrap it with context: `return err(\`serviceX failed: ${e}\`)`.

- **Boundary vs business logic**
  - Boundary code (network, disk, third-party SDKs)
    - Use `tryCatch()` and convert to `err(...)`.
    - Example:
      ```ts
      const got = await tryCatch(sdk.fetchThing())
      if (isErr(got)) return err(`sdk.fetchThing failed: ${got.error}`)
      ```
  - Business validation
    - Use `failure('some-literal')` for expected, matchable conditions.
    - Example:
      ```ts
      if (!repo) return failure('not-found')
      ```

- **Wrapping errors**
  - Good:
    ```ts
    const r = await doWork()
    if (isErr(r)) return err(`doWork failed: ${r.error}`)
    ```
  - Bad:
    ```ts
    if (isErr(r)) return err(r.error) // loses useful wrapping context
    ```

- **When to throw**
  - Only for programmer errors or initialization where higher-level code cannot meaningfully proceed. Otherwise return `err`/`failure`.

- **Consuming callers**
  - Pattern-match the returned error value directly (not a separate `code` field). Example:
    ```ts
    const r = await service()
    if (isErr(r)) {
      if (r.error === 'not-found') { /* handle not-found */ }
      return err(`service error: ${r.error}`)
    }
    ```

- **Operational**
  - Convert `err`/`failure` to logs/alerts at the application boundary (cron wrapper, HTTP handler). Avoid leaking sensitive data.

- **Anti-patterns**
  - No try/catch wrapping normal async flows.
  - No `err(r.error)` without adding wrapping context.
  - Do not check error shapes via direct property checks; call `isErr(value)`.

- **Short examples**
  - Boundary:
    ```ts
    const maybe = await tryCatch(externalSdk.get())
    if (isErr(maybe)) return err(`externalSdk.get: ${maybe.error}`)
    ```
  - Business:
    ```ts
    if (!user) return failure('not-found')
    ```